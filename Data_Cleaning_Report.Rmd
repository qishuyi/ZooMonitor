---
title: "Data Cleaning Report for Pueblo Zoo"
author: "Hinako Minagi, Riu Sakaguchi, Shuyi Qi"
date: "February 27 2020"
output: 
  html_document:
    theme: yeti
    toc: TRUE
    toc_depth: 5
    toc_float: TRUE
    smooth_scroll: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)

```

```{r Setup, echo = F}
#Only so that I can work on data cleaning part before the installing of packages and importing data
library(knitr)
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(tibble)

dogs_data <- read_csv("https://raw.githubusercontent.com/qishuyi/ZooMonitor/master/report_study_1579790635.csv", col_types = cols(Notes = col_character()))

```


#### **Introduction**

R is a programming language that enables users to write programs to perform data analysis and create data visualizations.

R Studio is a programming environment where we write R programs and execute them.

R/R Studio simplifies and automates the process of data cleaning and manipulation without the user directly interacting with a dataset. For instance, in Excel, users might need to go through the entire file to delete rows with incomplete data values while in R it can be done with one line of code.

R also allows users to perform higher-level data cleaning and manipulation with the packages it provides. For example, we can create a new column, 'day of week' (Mon, Tue, Wed, etc.), based on the existing 'date' column (YYYY-MM-DD) in the dataset. The creation of new columns can also be done with one line of code, instead of us manually going through each row to calculate and add the values. 

Our data cleaning process was directed by a few end goals we had regarding the final dataset. Firstly, we want the dataset to only contain columns that are helpful for our data analysis and visualization. Some columns in the dataset are auto-generated by the ZooMonitor system and do not provide relevant information to studying the behaviors of dogs (i.e., 'image_size'). Eventually, we hope to have a smallest set of variables that still enables us to perform effective analysis on the dataset. Secondly, we would like the column names to be simple yet without loss of information. Some variable names like 'Interval_Channel_1_Value' are too long and too hard to work with. In the cleaned dataset, we would want all variable names to be relatively short but still provides sufficient information about the meaning of the variables. Thirdly, some rows in the raw dataset contain both active and inactive behaviors while some rows contain neither active nor inactive behaviors. To facilitate the visualization process, each row in the final dataset needs to contain only one type of behavior, either active or inactive. 

To achieve our end goals, we have gone through a few data cleaning steps. We started by importing the csv file into RStudio, which allows us to use the R programming language to tidy and manipulate the dataset. We then removed the columns that are unnecessary for our data analysis and visualization, including the columns that are auto-generated by ZooMonitor and those that contain duplicated information. For instance, we eliminated the 'DateTime' column because there was already a 'Date' and a 'Time' column in the dataset. After that, we simplified some variable names, making them shorter and easier to work with. For example, we changed the variable name 'Interval_Channel_1_Value' to 'IC1_Value'. We still kept the names similar to their original format in case we want to change them back in the future. Last but not least, we removed the rows which contain neither active nor inactive behaviors, and splitted each row that contains both active and inactive behaviors into two rows. 

Moreover, we took a few additional steps to make the data easier to work with. Initially, the dataset contains a column which is 'Active' for observations that record active behaviors and is empty for those that record inactive behaviors. There is also such a column for 'Inactive'. We combined the two columns into one single column called 'Activeness' and the new column contains two types of values, 'Active' and 'Inactive'. In response to the combination of the two columns, we also combined the two columns for different types of active and inactive behaviors into one called "Activity".

***

#### **Instructions for Installing R and R Studio**



First, we will guide you through the process of installing R.

**[For Windows]** 

1. To begin, click on this [link](https://cran.rstudio.com/bin/windows/base/) to install R on a Windows device. 

2. On the newly opened page, click *"Download R 3.6.2 for Windows"* to continue with the installation. 

3. After clicking on the download link, follow any other directions given by the installation manual. 

\

 **[For Mac]** 

1. To begin, click on this [link](https://cran.rstudio.com/bin/macosx/) to install R on a Mac device. 

2. On the newly opened page, there are various blue links on the left hand side of the page. 
+ We will later select one of the three links that are given in this format *(____.pkg)*. 
+ The appropriate link to install R will depend on the version of the operating system for your Mac. 
+ Beside the three blue links in the *(____.pkg)* format, the website provides a description of the MacOS compatible with that installation link. 

3. Click on the appropriate link to continue with the installation. 
+ If you are unsure which MacOS version your Mac is currently running, this [website](https://support.apple.com/en-us/HT201260) provides support on how to check the version. 
+ An alternative is to update your MacOS to the latest version and click on *"R-3.6.2.pkg"*. 

4. After selecting the correct download link for your Mac, follow any other directions given by the installation manual. 

\

Now that R has been successfully installed on your computer, we will guide you through the process of installing R Studio. 

1. To begin, first click on this [link](https://rstudio.com/products/rstudio/download/#download)

2. Scroll down on the page below the section titled All Installers. 

3. Select the download link that is approrpiate for your operating system.

4. Follow any other directions given by the installation manual. 

\

Congratulations! R and R Studio should now be succesfully installed on your computer. 

***


#### **Using R Studio**

From now on, all the instructions pertain to R Studio since it is where we write R programs and execute them, as we mentioned earlier.

R Studio mainly consists of four parts:  
1. Your RScript (top left)  
2. The Console (bottom left)  
3. Your Environment (top right)  
4. Plots/Help (bottom right)

+ **"RScript"** is where you write and run (execute) codes. Notice that you need to actually run the codes to have them function. 

+ **"Console"** has two functions.First, it indicates whethere your codes functioned properly; if they did, your codes will appear in blue, otherwise an error will appear in red underneath your codes. If you write a function, the outcome will also appear in this Console. The second function of "Console" is similar to that of RScript: you can write codes! Unlike RScript, Console does not require you to run the codes, but to just press enter after writing the codes. 

+ **"Environment"** shows a list of data or objects you have read or created. You can view the data by clicking on those; they will appear as one of the tabs above the RScript.*
*Remark that you can only open objects with a blue arrow sign on the left.

+ **"Plots"** displays plots whenever they are created. "Help" takes you to the R Studio's instruction website by executing the command "help()". For example, if you struggled understading how to use the command "install.packages()," just put down "help(install.packages)" in either "RScript" or "Console" to know how it functions.

\
  
To begin and save an RScript, please follow the following steps:

 1. **Set the "Working Directory"** (where you will be storing your RScript)  
 "Session" in R Studio menu bar -> "Set Working Directory" -> "Choose Working Directory" -> Select a file you want to store your RScript in.
 
 2. **Create a new RScript**  
 "File" in R Studio menu bar -> "New File" -> "RScript"
 
 3. **Save your RScript**  
 "File" in R Studio menu bar -> "Save" or "Save As ..."
 
 4. **Open an existing RScript**  
 "File" R Studio menu bar -> "Open File" -> Select a file you want to open*  
 *You can open as many RScripts simultaneously as you want!

\

Now, let's start actually running some codes!

**Running Codes**  
First, **open a new RScript**. You will see a line of numbers on the left side, and these numbers indicate the line you are on. You can start writing a code from any line.   
Now, on the RScript, let's practice by **writing the equation "3+5"**. To execute this, you would either want to **click on the "Run" bottom at the top-right corner of the RScript** or **highlight the code and press enter**! You should now be seeing "[1] 8" on your Console, which indicates the outcome of your equation. This is basically how you run (or execute) your codes.

\

**Store the outcome**  
Let's continue with this example. In the future, you may want to have this outcome 8 to be stored in your Environment. To do so you have to go over two steps: name the object and store it. To begin, **write the code "number <- 3+5"** and run it. You will have an object called "number" in your Environment with its content "8." In this case, you have named the object "number" and stored it in the Environment.

Two basic things to remember:  

+ **"<-"** and **"="** have exactly the same meaning, which is "equal," and are completely interchangeable. Normally, on the left of this symbol, you will write the name under which you want to store the object and on the right, you will write the content of the object.  

+ **" + "** (addition), **" - "** (subtraction), **" * "** (multiplication), **" / "** (division), and **" ^ "** (power) are the algebraic symbols you would be using to conduct algebraic operations. 

+ Anything noted after the symbol **" # "** will not be run. These will appeaer in green on your RScript and are normally use to note what the code written under that does.  

*For example:*
```{r}
# Operating 3+5
3+5
```
For this, the "3+5" part will only be read.

***

#### **Data Cleaning Procedure**

Now, let's proceed to the data cleaning process. Here, we will introduce the actual process we have gone through to clean the Painted African Dogs' data.  

\

##### **Installing Packages**  
In our last example, we calculated 3+5 and stored the outcome only using a simple algebraic symbol. However, unfortunately, we will need to use **command** (or function) to conduct operations on data, unlike our example. Many of these commands live in a certain **package**, and to be able to use them in your R Studio, you will need to install the packages first. 

*Here's the command that lets you install the package:*
```{r, eval = F}
install.packages()
```

*After you have installed the package you needed, you will not want to run the code every time you open your RScript. Therefore, you can remove this code from your RScript after your done with installation.

\

So, here are all the packages you need to clean the Painted African Dogs' data. 

+ readr: Contain commands that read rectangular data (like 'csv', 'tsv', and 'fwf')
+ dplyr: Contain commands that clean data (select columns, remove rows, etc.)
+ tidyr: Contain commands that clean data (unite several columns, spread a column, etc.)

*And here are the codes that install these packages:*
```{r, eval = F}
install.packages("readr")
install.packages("tidyr")
install.packages("dplyr")
```

*During the installation, you have to wait until the line "Downlowded" appears in red on Console!

\

##### **Loading in Libraries**  

Even though you do not need to install the packages that you already have each time you open the app, you still need to call the package to be able to use the commands stored inside. That is to say, every time you open/reopen an RScript, whether the script is new or not, **you need to run the command that calls the packages.**

*Here are the commands that call the packages:*
```{r}
library(readr)
library(tidyr)
library(dplyr)
```

*Notice that you need not have the quotation marks in the parenthesis this time.  
**You should keep these codes on your RScript since you have to run these every time you use the commands stored in these packages.

You may have noticed that we did not install any packages before we used the commands "install.packages()" and "library()". This is because these commands are already stored in R, and there are many other basic commands that are like these!

\

##### **Importing Data**  

Now, using the **"readr" package**, we will import the data we want to use.    
Specifically, although we have otehr alternative options, we will use the **"read_csv()"** command in the this package because it is fast at reading large datasets.

*Now, this is the basic format of "read_csv" or "read.csv" command:*
```{r, eval=FALSE}
data_name <- read_csv("File name or URL")
```

\

In the parenthesis, you will be navigating the function to where the data is located. There are mainly three ways you can format this:     
  
 1. If you have the data stored in the **"Working Direcoty"**, then you can just **enter the exact file name (including the part after the dot) in quptation marks**. For example, if the data "data.csv" is stored in your working directory, you write as follows:
```{r, eval=F}
Example <- read_csv("data.csv")
```

\

 2. If the data is stored in **some other file/folder on your PC**, you need to **navigate the function to the file/folder from your working directory**. So, if the data "data.csv" is in the file "A," which is in the folder "B," which is in your working directory, then you write as follows:
```{r, eval = F}
Example2 <- read_csv("B/A/data.csv")
```
\

 3. If the data is stored somewhere online, such as Github, you will **write in the URL in the parenthesis**. This time, if the data has the URL "http:// ... .csv," you will have something like the following:
```{r, eval=F}
Example3 <- read_csv("http:// ... .csv")
```
\
You will repeat indicating the folders, dividing them by " / ", until you reach the dataset you want.
Also, notice that **the name under which you store your data on R Studio has no space in-between**.  
\
Finally, in our case, we decided to name the Painted African Dogs' data **"dogs_data"**. Please keep in mind that the following data-cleaning process will base off of this name.

\

##### **Inspecting the Data**

We have successfully installed necessary packages, loaded the libraries, and imported our data. Before beginning the data cleaning process, we must inspect the data. We begin by checking the number of rows the columns the data contains.

```{r}
dim(dogs_data)
```
We used the *dim()* function, and passed in the name of the data frame as the argument. The values that the function returned suggest that the raw data consists of 3409 observations and 25 different columns. 


\

Now, we will inspect the entire data frame. The **view()** function can be used to examine the entire data frame. Other functions such as **head()** and **tail()** can be used to examine the first or last couple of rows of the data frame, respectively. 

```{r, eval = F}
view(dogs_data)
head(dogs_data)
tails(dog_data)
```

\

Upon carefully exploration of the data, we compiled a list of actions to take in order to make the data easier to work with. 

- Remove columns that don't contain any useful information.
- Change some of the column names to make it easier to work with.
- Remove rows that don't contain any behavioral observations for the dog.
- Split rows that contain multiple behavioral observation.

\

##### **Removing Irrelevant Columns **

From here, we will finally begin the process of data cleaning. We will first remove columns that don't contain useful information for the purposes of anayzing the data. For the data on Painted African Dogs, we decided to remove the following columns:

- *Confirguration Name*
- *Observer*
- *Device ID*
- *DataTime*
- *Grid Size*
- *Image Size*
- *Channel Type*
- *Project Animals*
- *Duration*

\

To remove these columns, we will use the **select()** function from the **dplyr** package. This function will allow us to select columns we want to keep in the data frame, or alternatively select columns we want to remove from the data frame. In our case, there are more columns we want to keep than remove, so we will pursue the latter option. 

```{r}
dogs_data <- select(dogs_data, -`Configuration Name`, -Observer,-DeviceID,
                                  -DateTime, -`Grid Size`, -`Image Size`,-`Channel Type`,
                                  -`Project Animals`, -Duration) 

```

\

The first argument of the **select()** function is the data frame name of our concern. Since we want to remove columns from the data frame called *dogs_data*, we passed dogs_data as the first argument. Now, we want to pass in all the names of the columns we want to remove as arguments, separated by commas. In addition, we need to make sure to include a minus sign (-) infront of the column name to indicate that we want to remove these columns. Note that all column names consisting of two different words (I.e *Configuration Name*) must be sandwiched between **`**. These types of column names are tiresome to work with, and is the main focus of the next section where we work on renaming column names. Lastly, we reassign the modified data frame back to *dogs_data*. Thus, *dogs_data* is now the modified version of the original data frame, containing everything besides the columns we removed above. 

\

Before moving on, we check to make sure that the columns were properly removed. A quick method is to check for the number of columns in the modified version of the data frame. Since we removed 9 columns from the original 25, we should be left with 16 columns. To do this, we can use the **ncol()** function, and pass in the name of the data frame as the argument. 

```{r}
ncol(dogs_data)
```

\

Since the function returned a value of 16, it appears as though the columns were removed correctly. However, there is always a case in which we refered to the wrong column name, or accidentally removed a column that we intended to keep. Since there are only a limited number of columns, we can use the **colnames()** function to check the names of all columns in the data frame. Again, we pass the name of the data frame as the argument.


```{r}
colnames(dogs_data)
```
\

The output suggests that all and only the columns we wished to remove were deleted from the data frame. While the two checks we performed above were not necessary, they can serve as a useful method for assuring that the columns were removed correctly. 

\

##### **Renaming Columns **

Now, we will rename some of the column names to simplify process of analyzing the data. In general, shorter column names that still effectively depict the information it contains are the most convinient. As mentioned earlier, column names consisting of multiple words are inefficient and troublesome to work with. Through this process, our aim is to get rid of "spaces" in column names, as well as shorten them whenever appropriate. Upon examining the columns in the data set, we decided to make the following changes:


Old Column Name                       | New Column Name
--------------------------------------| ------------------
*Session Start Time*                  | *Session_Start_Time*
*Session End Time*                    | *Session_End_Time*
*Focal Name*                          | *Name*
*Interval Channel 1 Name*             | *IC1_Name*
*Interval Channel 1 Name*             | *IC1_Value*
*Interval Channel 1 Social Modifier*  | *IC1_Social_Modifier*
*Interval Channel 2 Name*             | *IC2_Name*
*Interval Channel 2 Value*            | *IC2_Value*

\

To make these changes, we will use the **rename()** function from the **dplyr** package. This function allows us to precisely specify and change the columns that we wish to rename. Some frequently used methods of removing spaces from column names include replacing spaces with periods marks or underscores. While will opt to use underscores, this choice is simply a matter of preference.

```{r}
dogs_data <-  rename(dogs_data, Session_Start_Time = `Session Start Time`,
                                  Session_End_Time = `Session End Time`, 
                                  Name = `Focal Name`,
                                  Frame_Number = `Frame Number`,
                                  IC1_Name = `Interval Channel 1 Name`,
                                  IC1_Value = `Interval Channel 1 Value`,
                                  IC1_Social_Modifier = `Interval Channel 1 Social Modifier`,
                                  IC2_Name = `Interval Channel 2 Name`,
                                  IC2_Value = `Interval Channel 2 Value`)
```

\

Like the **select()** function we deployed earlier, the first argument we must pass in the function is the name of the data frame. This informs the function of where the column names are coming from. The general syntax for the succeeding arguments is *new column name = current column name*. We can rename as many columns as desired, as long as each instance is separated with a comma. Again, we reassign the modified data back into *dogs_data*, so that it contains the updated column names. 

\

We can check to make sure that the column names were all changed properly. Again, we use the **colnames()** function to do this. 

```{r}
colnames(dogs_data)
```

\

The output is the list of column names in the modified dogs data. By inspection, we can be assured that all of the desired changes were applied correctly.

\

##### **Omitting Rows**

Prior to this point, we have manipulated our data such that it consists of only the columns we may need for future analysis, and renamed the column names for simplicity purposes. The next step, removing rows missing behavioral observations, is crucial to the data cleaning process. Handling missing data can be very time consuming when done manually. However, R provides a fast and efficient way of dealing with this issue. 

In the dogs data, behavioral observations are stored in two columns: *IC1_Value* and *IC2_Value*. Note that these are the renamed versions of Interval Channel 1 Value and Interval Channel 2 Value. We want to remove only the rows that are missing values for **both** of these columns. Later on, we will combine these two columns into a single column to make visualizing data simpler. For now, however, we must consider active and inactive behaviors as two separate columns. 

The **filter()** function from the **dplyr** package allows us to keep only a subset of rows we want from the data frame. Notice that removing rows that are missing values for **both** *IC1_Value* and *IC2_Value* is tantamount to keeping all rows that is **not** missing values for these two columns. 

```{r}
dogs_data <- filter(dogs_data, !(is.na(IC1_Value) & is.na(IC2_Value)))
```
\

Again, the first argument of the function specifies the data frame of our concern. The second argument is a little invovled, so we first will decompose and explain each part individually. The *is.na()* function esentially checks to see whether a value is missing. Hence, is.na(IC1_Value) is going through every row of the dogs data and checking whether there is a missing value in the *IC1_Value* column. is.na(IC2_Value) follows the exact same procedure, and verifies missing values in the *IC2_Value* column of the data frame. Combining these two expressions with **&**, we are now going through the data and checking for rows missing values for **both** columns. At this point, the function will keep all and only the rows with missing values for both *IC1_Value* and *IC2_Value*. By putting **!** infront of the expression, this will allow us to achieve our goal of keeping all and only the rows **not** missing values for the two columns. Lastly, we reassign the modified version of the data back to *dogs_data*. 

\

When we first inspected the initial data, there were a total of 3409 rows. We now check for the number of rows in our current data frame, after omitting rows missing behavioral observations. 

```{r}
nrow(dogs_data)
```
\

Our newly modified data frame has a total of 3173 rows. Hence, there were 236 rows with missing observations. Now that we have successfully handled rows with missing values, we will address rows with multiple behavioral observations in the following section. 

\

##### **Splitting Rows**


\


\

#### **Extra Steps**
In our last section, we have introduced the basic data-cleaning procedure that is useful for and applicable to many datasets.  
\
One last thing to be mentioned is that we have taken two more additional steps to further clean the data.  Those are:  

 1.**Combining the columns "IC1_Name" and "IC2_Name"** so that we have the values "Active" and "Inactive" in a single column.  
 2. **Combing the columns "IC1_Value" and "IC2_Value"** so that we have the values of activity, such as sleeping and eating, in a single columns.  
\
For these two steps, we use the command **"unite()"** from the "tidyr" package and **"mutate()"** from the **dplyr** package.   
\

*Here are how we use those commands:*
```{r}
#Step 1
dogs_data <- unite(dogs_data, "Activeness", c(IC1_Name, IC2_Name), remove = T)
dogs_data <- mutate(dogs_data, Activeness = gsub("NA_", "", Activeness))
dogs_data <- mutate(dogs_data, Activeness = gsub("_NA", "", Activeness)) 

#Step2
dogs_data <- unite(dogs_data, "Activity", c(IC1_Value, IC2_Value), remove = T)
dogs_data <- mutate(dogs_data, Activity = gsub("NA_", "", Activity))
dogs_data <- mutate(dogs_data, Activity = gsub("_NA", "", Activity))  
```

Here, basically, **"unite()"** combines the columns "IC1_Name" and "IC2_Name" or "IC1_Value" and "IC2_Value" and **"mutate()"** creates, or in this case replace the old one with, a new column; just like this case, by making the new column name the same as the one we have in the original dataset, the command "mutate()" just replaces all the values of the given column instead of creating a completely new one.  
Lastly, **"gsub()"** removes the "NA_" and "_NA" we undesirably obtained from the combining process. 

\

We hope that this report was helpful for you! The introduction highlights some big picture and the general process in which we cleaned the data. The later sections illustrate more technical details and provide explanations along the way. The data cleaning procedure covers the minimum necessary steps taken in order to create visualizations and analyze the data. While not explicitly presented in this document, there are a wide range of steps that can be taken to enrich the content of the data. The following are some additional modifications we have made using R to the dogs data as of February 27th 2020:

- Added a column for day of the week *(I.e Wednesday)*
- Added a column for food *(I.e Bones)*
- Added a column for season *(I.e. Summer)*
- Added a column for average temperature 
- Added a column for weather

