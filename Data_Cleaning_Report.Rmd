---
title: "Data Cleaning Report for Pueblo Zoo"
output:
  html_document:
    theme: yeti
    toc: TRUE
    toc_depth: 5
    toc_float: TRUE
    smooth_scroll: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)

```

```{r Setup, echo = F}

#Only so that I can work on data cleaning part before the installing of packages and importing data
library(knitr)
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(tibble)

dogs_data <- read_csv("https://raw.githubusercontent.com/qishuyi/ZooMonitor/master/report_study_1579790635.csv", col_types = cols(Notes = col_character()))

```

<br>

#### **Notes**
Hello! This document is created to facilitate your understanding on how we cleaned the Painted African Dogs dataset. The **Introduction** section provides an overview of the technologies we used to clean the dataset, the specific steps we took and the reasons why we took these steps.  

If you would like to know about the data cleaning process in more detail, you can proceed to the later sections but you should be able to get a general idea just by reading the Introduction.  

After you read the Introduction and you are potentially interested in using the R programming language and R Studio, the **Instructions for Installing R and R Studio** and **Using R Studio** sections will help you get started.  

If you just want to know more about the data cleaning process without using R/RStudio, feel free to skip these two sections and proceed to the later ones. 

We hope this document is helpful and you enjoy reading it!

***

#### **Introduction**

**R and RStudio**  
R is a programming language that enables users to write programs to perform data analysis and create data visualizations.  

R Studio is a programming environment where we write R programs and execute them.

**Why they are useful**  
R/R Studio simplifies and automates the process of data cleaning and manipulation **without** the user directly interacting with datasets. For instance, Excel requires the user to go through the entire file to delete rows with incomplete data values while in R this can be done with one line of code.

R also allows users to perform higher-level data **cleaning and manipulation** with the **packages** it provides. For example, we can create a new column, *Day_of_Week* ("*Mon*", "*Tue*", "*Wed*", etc.), based on the existing *Date* column (i.e., "*YYYY-MM-DD*") in the dataset. The creation of new columns can also be done with one line of code, instead of us manually going through each row to calculate and input the values. 

**Goals for data cleaning**  
Our data cleaning process was directed by a few end goals we had regarding the final dataset. Firstly, we wanted the dataset to **only contain** columns that are helpful for our data analysis and visualization. Some columns in the dataset are auto-generated by the ZooMonitor system and do not provide relevant information to the study of dogs's behaviors (i.e., *Image Size*, *Grid Size*). Eventually, we hoped to have the **smallest** set of variables that still enables us to perform effective analysis on the dataset. Secondly, we would like the column names to be simple yet without loss of information. Some variable names like *Interval Channel 1 Value* were too long and tedious to work with. In the cleaned dataset, we would want all variable names to be relatively **short** but still provides sufficient information about the meaning of the variables. Thirdly, some rows in the raw dataset contain **both** active and inactive behaviors while some rows contain **neither** active nor inactive behaviors. For a smoother visual creation process, each row in the final dataset should contain **only one type of behavior, either active or inactive**. 

**Primary data cleaning steps**  
To achieve our end goals, we have gone through a few data cleaning steps. We started by importing the csv file into RStudio, which allows us to use the R programming language to tidy and manipulate the dataset. We then removed the columns that are unnecessary for our data analysis and visualization, including the columns that are auto-generated by ZooMonitor and those that contain duplicate information. For instance, we eliminated the *DateTime* column because there was already a *Date* and a *Time* column in the dataset. After that, we simplified some variable names, making them shorter and easier to work with. As an example, we changed the variable name *Interval Channel 1 Value* to *IC1_Value*. We still kept the names similar to their initial format in case we need to refer back to the original dataset in the future. Lastly, we **removed** the rows which contain **neither** active nor inactive behaviors, and **split** any row that contains **both** active and inactive behaviors into two rows. 

**Additonal steps**  
Moreover, we took a few additional steps to make the data easier to work with. Initially, the dataset contained a column which has the value "*Active*" for observations that record active behaviors and is empty for those that record inactive behaviors. There is also a similar column which either contains the value "*Inactive*" or is empty. We **combined** the two columns into one single column called *Activeness* and the new column contains two types of values, "*Active*" and "*Inactive*". We also **combined** the two columns specifying different types of active and inactive behaviors into one called *Activity*.

***

#### **Instructions for Installing R and R Studio**



First, we will guide you through the process of installing R.

**[For Windows]** 

1. To begin, click on this [link](https://cran.rstudio.com/bin/windows/base/) to install R on a Windows device. 

2. On the newly opened page, click *"Download R 3.6.2 for Windows"* to continue with the installation. 

3. After clicking on the download link, follow any other directions given by the installation manual. 

\

 **[For Mac]** 

1. To begin, click on this [link](https://cran.rstudio.com/bin/macosx/) to install R on a Mac device. 

2. On the newly opened page, there are a number of blue links on the left-hand side.
+ We will later select one of the three links that end in *.pkg*. 
+ The appropriate link for installing R will depend on the version of your MacOS. 
+ In the paragraphs beside each of the three blue links in the *(____.pkg)* format, the website provides a description of the MacOS versions that are compatible with the particular installation link. 

3. Click on the appropriate link to continue with the installation. 
+ If you are unsure which macOS version your Mac is currently running, this [website](https://support.apple.com/en-us/HT201260) provides support on how to check your version. 
+ An alternative is to update your macOS to the latest version and click on *"R-3.6.2.pkg"*. 

4. After selecting the correct download link for your Mac, follow any other directions given by the installation manual. 

\

Now that R has been successfully installed on your computer, we will guide you through the process of installing R Studio. 

1. To begin, first click on this [link](https://rstudio.com/products/rstudio/download/#download)

2. Scroll down on the page below the section titled "All Installers". 

3. Select the download link that is approrpiate for your operating system.

4. Follow any other directions given by the installation manual. 

\

Congratulations! R and R Studio should now be succesfully installed on your computer. 

***


#### **Using R Studio**

From now on, all the instructions pertain to R Studio since this is where we write and execute R programs, as we mentioned earlier.

![The R Studio User Interface]("place holder")

R Studio mainly consists of four parts:  
1. Your RScript (top-left)  
2. The Console (bottom-left)  
3. Your Environment (top-right)  
4. Plots/Help (bottom-right)

+ **"RScript"** is where you write and run (execute) codes. You will notice that you need to actually run the codes in order to have them function. 

+ **"Console"** has two functions. First, it indicates whether your code functioned properly; if they did, your code will appear in blue, and otherwise an error will appear in red underneath your code. The second function of "Console" is similar to that of RScript: you can write codes! Unlike "RScript," "Console" will immidiately run the any code you wrote after you press enter.

+ **"Environment"** displays a list of data or objects you have read or created. You can view the data by clicking on those; they will appear as a tab above the RScript. Note that you can only open objects with a blue arrow sign on the left.

+ **"Plots"** display plots whenever they are created. 

+ **"Help"** takes you to the R Studio's instruction website by executing the command **help()**. For example, if you are struggling to understading how to use the command **install.packages()**, just write **help(install.packages)** and run it either in "RScript" or "Console" to have the instruction page appear. 

\

Here are some steps to begin wokring with an RScript:   

 1. **Set the "Working Directory"** (where you store your RScript)  
CLick "Session" in R Studio menu bar $\rightarrow$ "Set Working Directory" $\rightarrow$ "Choose Working Directory" $\rightarrow$ Select a file you want to store your RScript in.
 
 2. **Create a new RScript**  
 CLick "File" in R Studio menu bar $\rightarrow$ "New File" $\rightarrow$ "RScript"
 
 3. **Save your RScript**  
 CLick "File" in R Studio menu bar $\rightarrow$ "Save" or "Save As..."
 
 4. **Open an existing RScript**  
 Click "File" in R Studio menu bar $\rightarrow$ "Open File" $\rightarrow$ Select a file you want to open. You can have as many RScripts open simultaneously as you want!

\

Now, let's start running some code!

**Running Code**  
First, open a new RScript. You will see a vertical line of numbers on the left, which indicates the line you are on. You can start writing a code from any line.   
Now, on the RScript, let's practice by writing an equation "3+5". To execute this, you would either want to click on the "Run" button at the top-right corner of the RScript or highlight the code and press enter! You should now be seeing "[1] 8" on your Console, which indicates the outcome of your equation. This is how you run (or execute) your code. 

\

**Store the outcome**  
Let's continue with this example. In the future, you may want to have this outcome "8" stored in your Environment. To do so, you will be going over two steps: name the object, and store it. To begin, write the code "number <- 3+5" and run it. You will have an object called "number" in your Environment with its stored value "8." In this example, you have named the object "number" and stored the integer "8" within it.

Two basic things to remember:  

+ **"<-"** and **"="** have exactly the same meaning, which is "equal," and are completely interchangeable. Normally, on the left of these symbols, you will write the name under which you want to store the object and on the right, you will write the code describing the object.  

+ **" + "** (addition), **" - "** (subtraction), **" * "** (multiplication), **" / "** (division), and **" ^ "** (power) are the symbols you would be using to compute normal algebraic operations. 

+ Anything written after the symbol **" # "** will not be run. These will appeaer in green on your RScript and are normally employed to provide comments/descriptions about the code.

*For example:*
```{r}
# Operating 3+5
3+5
```
For this case, "# Operating 3+5" will not be executed. In otherwords, anything that follows **" # "** is esentially ignored by RStudio. 

***

#### **Data Cleaning Procedure**

Now, let's proceed to the data cleaning process. Here, we will introduce the actual process we have taken to clean the Painted African Dogs data.  

<br>

##### **Installing Packages**  
In our last example, we calculated "3+5" using only a simple algebraic symbol and stored the outcome. However, we will in many cases need to use **commands** (or function) to conduct operations on data. Many of these commands reside in a certain **package**, and to be able to use them in your R Studio, you will need to install the packages first. 

*Here's the command that lets you install the package:*
```{r, eval = F}
install.packages("package name")
```

*After you have installed the package you needed, you will not want to run the code every time you open your RScript. Therefore, you can remove this code from your RScript after you're done with the installation.

\

Here are all the packages you need to clean the Painted African Dogs data. 

+ readr: Contain commands that read in data (like 'csv', 'tsv', and 'fwf')
+ dplyr: Contain commands that clean data (select columns, remove rows, etc.)
+ tidyr: Contain commands that clean data (unite several columns, spread a column, etc.)
+ tibble: Contain commands that display and plots

*And here is the code to install these packages:*
```{r, eval = F}
install.packages("readr")
install.packages("tidyr")
install.packages("dplyr")
install.packages("tibble")
```

*During the installation, you have to wait until the line "Downlowded" appears in red on Console!

<br>

##### **Loading in Libraries**  

Even though you do not need to run the installation codes we just presented, you still need to call the packages every time you open R Studio to be able to use the commands stored inside. Thus, every time you open/reopen an RScript, whether the script is new or not, **you need to run the command that calls the packages.**

*Here are the commands that call the packages:*
```{r}
library(readr)
library(tidyr)
library(dplyr)
library(tibble)
```

*Notice that you need not have the quotation marks in the parenthesis this time.  
**It is a good practice to keep this code at the very beginning your RScript, since you will need to run it everytime you open/reopen an RScript.

You may have noticed that we did not install any packages before we used the commands **install.packages()** and **library()**. This is because these commands are some of the many basic commands that are provided to you by default. 

<br>

##### **Importing Data**  

Now, using the **readr package**, we are going to import the data of our choice.    
While there are a couple of possible methods, we will use the **read_csv()** command in this package because it is fast at reading large datasets.

*This is the basic syntax of the "read_csv()" function:*
```{r, eval=FALSE}
data_name <- read_csv("File name or URL")
```

\

In the parenthesis, you will need to specify where the data is located. There are three main ways you can format this:     
  
 1. If you have the data stored in the *Working Directory*, then you can just enter the exact file name (including the part after the dot) in quptation marks. For example, if the data named "my_data.csv" is stored in your working directory, you should write as follows:
```{r, eval=F}
Example <- read_csv("my_data.csv")
```

\

 2. If the data is not stored in the *Working Directory* but in some other folder, you need to navigate the function to that specific folder from your *Working Directory*. For example, suppose that from your *Working Directory*, you need to click on folder "B", and then another folder "C", in order to access "my_data.csv". Then you should write as follows:
```{r, eval = F}
Example2 <- read_csv("B/C/data.csv")
```

\

You will repeat this process, separating each folder along the way with " / ", until you reach the location of your data set. 

\

 3. If the data is stored somewhere online, such as Github, you need to write the URL of the data in the parenthesis. If the data has the URL "http:// ... .csv," you will need to type something like the following:
```{r, eval=F}
Example3 <- read_csv("http:// ... .csv")
```
\

*Notice that the name under which you store your data on R Studio has no space in-between. 

Finally, in our case, we decided to name the Painted African Dogs data *dogs_data*. Please keep in mind that the following data-cleaning process will be based off of this name. (In otherwords, our data is stored in a variable called *dogs_data*, so whenever we want to refer to this data set, we will type *dogs_data*). 

<br>

##### **Inspecting the Data**

We have successfully installed necessary packages, loaded the libraries, and imported our data. Before beginning the data cleaning process, we will need to inspect the data. We begin by checking the number of rows the columns the data contains.

```{r}
dim(dogs_data)
```
We used the **dim()** function, and passed in the name of the data frame (*dogs_data*) as the argument. The values that the function returned suggest that the raw data consists of 3409 observations and 25 different columns. 


\

Now, we will inspect the entire data frame. The **view()** function can be used to examine the entire data frame. Other functions such as **head()** and **tail()** can be used to examine the first or last couple of rows of the data frame, respectively. 

```{r, eval = F}
view(dogs_data)
head(dogs_data)
tails(dog_data)
```

\

Upon a careful exploration of the data, we compiled a list of actions to take in order to make the data easier to work with. 

- Remove columns that don't contain any useful information.
- Change some of the column names to make it easier to work with.
- Remove rows that don't contain any behavioral observations of the dog.
- Split rows that contain multiple behavioral observations.

<br>

##### **Removing Irrelevant Columns **

From here, we will finally begin the actual process of data cleaning. We will first remove columns that don't contain useful information for the purposes of anayzing the data. For the data on Painted African Dogs, we decided to remove the following columns:

- *Confirguration Name*
- *Observer*
- *Device ID*
- *DataTime*
- *Grid Size*
- *Image Size*
- *Channel Type*
- *Project Animals*
- *Duration*

\

To remove these columns, we will use the **select()** function from the **dplyr** package. This function will allow us to select columns we want to keep in the data frame, or alternatively select columns we want to remove from the data frame. In our case, there are more columns we want to keep than remove, so we will pursue the latter option. 

```{r}
dogs_data <- select(dogs_data, -`Configuration Name`, -Observer,-DeviceID,
                                  -DateTime, -`Grid Size`, -`Image Size`,-`Channel Type`,
                                  -`Project Animals`, -Duration) 

```

\

The first argument of the **select()** function is the data frame name of our concern. Since we want to remove columns from the data frame called *dogs_data*, we passed dogs_data as the first argument. Now, we want to pass in all the names of the columns we want to remove as arguments, separated by commas. In addition, we need to make sure to include a minus sign **(-)** in front of the column name to indicate that we want to remove these columns. Note that all column names consisting of two different words (I.e *Configuration Name*) must be sandwiched between **`**. Column names of this nature are tiresome to work with, and is the main focus of the next section where we work on renaming column names. Lastly, we reassign the modified data frame back to *dogs_data* so that *dogs_data* is now the modified version of the original data frame, containing everything besides the columns we removed above. 

\

Before moving on, we check to make sure that the columns were properly removed. A quick check is to print the number of columns in the modified version of the data frame. Since we have removed 9 columns from the original 25, we should be left with 16 columns. To do this, we can use the **ncol()** function, and pass in the name of the data frame as the argument. 

```{r}
ncol(dogs_data)
```

\

Since the function returned a value of 16, it appears as though the columns were removed correctly. However, there is always a possibly that we referred to the wrong column name, or accidentally removed a column that we intended to keep. Since there are only a limited number of columns, we can use the **colnames()** function to check the names of all columns in the data frame (This would not be realistic if we had hundreds of columns). Again, we pass the name of the data frame as the argument.


```{r}
colnames(dogs_data)
```
\

The output suggests that all and only the columns we wished to remove were deleted from the data frame. While the two checks we performed above were not necessary, they can serve as useful methods for assuring that the columns were removed correctly. 

<br>

##### **Renaming Columns **

Now, we will rename some of the column names to simplify process of analyzing the data. In general, shorter column names that still effectively depict information about the variable are most convinient. As mentioned earlier, column names consisting of multiple words are inefficient and troublesome to work with. Through this process, our aim is to get rid of the spaces in column names, as well as shorten them whenever appropriate. Upon examining the columns in the data set, we decided to make the following changes:


Old Column Name                       | New Column Name
--------------------------------------| ------------------
*Session Start Time*                  | *Session_Start_Time*
*Session End Time*                    | *Session_End_Time*
*Focal Name*                          | *Name*
*Interval Channel 1 Name*             | *IC1_Name*
*Interval Channel 1 Name*             | *IC1_Value*
*Interval Channel 1 Social Modifier*  | *IC1_Social_Modifier*
*Interval Channel 2 Name*             | *IC2_Name*
*Interval Channel 2 Value*            | *IC2_Value*

\

To make these changes, we will use the **rename()** function from the **dplyr** package. This function allows us to precisely specify and change the names of columns. **Some frequently used methods of removing spaces from column names include** replacing spaces with periods or underscores. While we will opt to use underscores, this choice is simply a matter of preference.

```{r}
dogs_data <-  rename(dogs_data, Session_Start_Time = `Session Start Time`,
                                  Session_End_Time = `Session End Time`, 
                                  Name = `Focal Name`,
                                  Frame_Number = `Frame Number`,
                                  IC1_Name = `Interval Channel 1 Name`,
                                  IC1_Value = `Interval Channel 1 Value`,
                                  IC1_Social_Modifier = `Interval Channel 1 Social Modifier`,
                                  IC2_Name = `Interval Channel 2 Name`,
                                  IC2_Value = `Interval Channel 2 Value`)
```

\

Like the **select()** function we deployed earlier, the first argument we must pass in the function is the name of the data frame. This informs the function of where the column names are coming from. The general syntax for the succeeding arguments is *new column name = current column name*. We can rename as many columns as we desire, as long as each instance is separated by a comma. Again, we reassign the modified data back into *dogs_data* so that it contains the updated column names. 

\

We can check to make sure that the column names were all changed properly. Again, we use the **colnames()** function to do this. 

```{r}
colnames(dogs_data)
```

\

The output is the list of column names in the modified dogs data. By inspection, we can be assured that all of the desired changes were applied correctly.

<br>

##### **Omitting Rows**

Prior to this point, we have manipulated our data such that it consists of only the columns we may need for future analysis and renamed the column names for the sake of simplification. The next step, removing rows missing behavioral observations, is crucial to the data cleaning process. Handling missing data can be very time consuming when done manually. However, R provides a fast and efficient way of dealing with this issue. 

In the dogs data, behavioral observations are stored in two columns: *IC1_Value* and *IC2_Value*. Note that these are the renamed versions of Interval Channel 1 Value and Interval Channel 2 Value. We want to remove only the rows that are missing values for **both** of these columns. Later on, we will combine these two columns into a single column to visualize the data more easily. For now, however, we must consider active and inactive behaviors as two separate columns. 

The **filter()** function from the **dplyr** package allows us to keep only a subset of rows we want from the data frame. Notice that removing rows that are missing values for **both** *IC1_Value* and *IC2_Value* is tantamount to keeping all rows that is **not** missing values for both of these columns. 

```{r}
dogs_data <- filter(dogs_data, !(is.na(IC1_Value) & is.na(IC2_Value)))
```
\

Again, the first argument of the function specifies the data frame of our concern. The second argument is a little invovled, so we will first decompose and explain each part individually. The *is.na()* function esentially checks to see whether a value is missing. Hence, is.na(IC1_Value) is going through every row of the dogs data and checking whether there is a missing value in the *IC1_Value* column. is.na(IC2_Value) follows the exact same procedure, and verifies missing values in the *IC2_Value* column of the data frame. By combining these two expressions with **&**, we are now going through the data and checking for rows missing values for **both** columns. At this point, the function will keep all and only the rows with missing values for both *IC1_Value* and *IC2_Value*. By putting **!** in front of these expressions, we can achieve our goal of keeping all and only the rows that are **not** missing values for the two columns. Lastly, we reassign the modified version of the data back to *dogs_data*. 

\

When we first inspected the initial data, there were a total of 3409 rows. We now check for the number of rows in our current data frame, after omitting rows that are missing behavioral observations. 

```{r}
nrow(dogs_data)
```
\

Our newly modified data frame has a total of 3173 rows. Hence, there were 236 rows with missing observations. Now that we have successfully handled rows with missing values, we will address rows with multiple behavioral observations in the following section. 

<br>

##### **Splitting Rows**

After removing rows with no behavioral observations, there are also rows containing both active and inactive observations. Ideally, we would want each row to contain just one behavior (either active or inactive) so that when we analyze a row in the dataset, we do not have to vacillate between the two behaviors. Finding rows with data for two types of behaviors and splitting them are both time-consuming tasks, so we can employ R to automate the tasks for us. 

Recall that in the dataset the behaviors are recorded in two columns: *IC1_Value* and *IC2_Value*.  

*IC1_Value* is either an active dog behavior or "*na*", and *IC2_Value* is either an inactive dog behavior or "*na*". ("*na*" indicates **missing value** for the variable.)

Therefore, we would like find the rows with "*na*" in **neither** *IC1_Value* **nor** *IC2_Value*, make a copy of each of these rows, write "*na*" in the *IC2_Name* and *IC2_Value* columns for one of them and "*na*" in the *IC1_Name* and *IC1_Value* for the other.

```
duplicate_indices <- which((!is.na(dogs_data$IC1_Value)) & (!is.na(dogs_data$IC2_Value)))
```
We first ran the above command to find the rows that contain both active and inactive behaviors. The row numbers are saved in a variable named *duplicate_indices*.

```
for (row_num in duplicate_indices) {
  duplicate_row <- dogs_data[row_num,]
  dogs_data[row_num, 15] <- NA
  dogs_data[row_num, 16] <- NA
  duplicate_row[, 12] <- NA
  duplicate_row[, 13] <- NA
  dogs_data <- rbind(dogs_data, duplicate_row)
}
```
We then iterate through each row number in *duplicate_indices* and ask the program to do the following in each iteration:  

- Get the observation at the given row number and make a copy of it  
- Change *IC2_Name* and *IC2_Value* to "*na*" in the original row  
- Change *IC1_Name* and *IC1_Value* to "*na*" in the copy  
- Add the copy at the end of the dataset  

Our modified data frame now has 3264 rows. At this point we have completed all the necessary data cleaning steps. In the next section we will discuss some additional steps we took to make the dataset easier to work with.


***

#### **Extra Steps**
In our last section, we have introduced the basic data-cleaning procedure that is useful for and applicable to not only *dogs_data* but also many other datasets with a similar structure. 


One last thing we would like to mention is that we have actually taken two more additional steps to further clean the data.  
Those are:  

 1.Combining the columns *IC1_Name* and *IC2_Name* so that we have the values "*Active*" and "*Inactive*" in a stored in a single column.  
 2. Combing the columns *IC1_Value* and *IC2_Value* so that we have the values of activity, such as sleeping, eating, etc, stored in a single column.  
\
For these two steps, we use the command **unite()** from the **tidyr** package and **mutate()** from the **dplyr** package.   


*Here are how we deploy these functions:*
```{r}
#Step 1
dogs_data <- unite(dogs_data, "Activeness", c(IC1_Name, IC2_Name), remove = T)
dogs_data <- mutate(dogs_data, Activeness = gsub("NA_", "", Activeness))
dogs_data <- mutate(dogs_data, Activeness = gsub("_NA", "", Activeness)) 

#Step2
dogs_data <- unite(dogs_data, "Activity", c(IC1_Value, IC2_Value), remove = T)
dogs_data <- mutate(dogs_data, Activity = gsub("NA_", "", Activity))
dogs_data <- mutate(dogs_data, Activity = gsub("_NA", "", Activity))  
```

Here, the function **unite()** combines the columns *IC1_Name* and *IC2_Name* or *IC1_Value* and *IC2_Value* and **mutate()** creates, or in this case replace the old one with, a new column. With the **mutate()** function, by assigning the old name (before " = "), the command just replaces all the values of the original column instead of creating a completely new one. Lastly, **gsub()** removes the "*NA_*" and "*_NA*," from the values of the merged columns. (For example, when we merged the columns, we got values such as *"NA_Sleeping"*, or *"Alert_NA"*. We used the **mutate()** and **gsub()** functions so that the values in the new column would appear as *"Sleeping"* and *"Alert"*, respectively).

***

#### **Concluding Remarks**

We hope that this report was helpful for you! The introduction highlights some big picture as well as the general process in which we cleaned the data. The later sections illustrate the more technical details and provide detailed explanations along the way. The data cleaning procedure covers the minimum necessary steps taken in order to create visualizations and analyze the data. While not explicitly presented in this document, there are a wide range of measures that can be taken to enrich the content of the data. The following are some additional modifications we have made using R to the *dogs_data* as of February 27th 2020:

- Added a column for day of the week *(I.e Wednesday)*
- Added a column for food *(I.e Bones)*
- Added a column for season *(I.e. Summer)*
- Added a column for average temperature 
- Added a column for weather

\


**Authors: Shuyi Qi, Hinako Minagi, Riu Sakaguchi** 

**Date: February 27 2020**
